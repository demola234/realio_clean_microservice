// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

type AmenityCategory string

const (
	AmenityCategoryFeature   AmenityCategory = "Feature"
	AmenityCategoryAmenity   AmenityCategory = "Amenity"
	AmenityCategoryAppliance AmenityCategory = "Appliance"
	AmenityCategoryUtility   AmenityCategory = "Utility"
	AmenityCategoryParking   AmenityCategory = "Parking"
)

func (e *AmenityCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AmenityCategory(s)
	case string:
		*e = AmenityCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for AmenityCategory: %T", src)
	}
	return nil
}

type NullAmenityCategory struct {
	AmenityCategory AmenityCategory `json:"amenity_category"`
	Valid           bool            `json:"valid"` // Valid is true if AmenityCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAmenityCategory) Scan(value interface{}) error {
	if value == nil {
		ns.AmenityCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AmenityCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAmenityCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AmenityCategory), nil
}

type PropertyCategory string

const (
	PropertyCategoryRent     PropertyCategory = "Rent"
	PropertyCategorySale     PropertyCategory = "Sale"
	PropertyCategoryBuy      PropertyCategory = "Buy"
	PropertyCategoryLease    PropertyCategory = "Lease"
	PropertyCategoryLand     PropertyCategory = "Land"
	PropertyCategoryMortgage PropertyCategory = "Mortgage"
)

func (e *PropertyCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PropertyCategory(s)
	case string:
		*e = PropertyCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for PropertyCategory: %T", src)
	}
	return nil
}

type NullPropertyCategory struct {
	PropertyCategory PropertyCategory `json:"property_category"`
	Valid            bool             `json:"valid"` // Valid is true if PropertyCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPropertyCategory) Scan(value interface{}) error {
	if value == nil {
		ns.PropertyCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PropertyCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPropertyCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PropertyCategory), nil
}

type PropertyStatus string

const (
	PropertyStatusAvailable PropertyStatus = "Available"
	PropertyStatusSold      PropertyStatus = "Sold"
	PropertyStatusRented    PropertyStatus = "Rented"
	PropertyStatusPending   PropertyStatus = "Pending"
)

func (e *PropertyStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PropertyStatus(s)
	case string:
		*e = PropertyStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PropertyStatus: %T", src)
	}
	return nil
}

type NullPropertyStatus struct {
	PropertyStatus PropertyStatus `json:"property_status"`
	Valid          bool           `json:"valid"` // Valid is true if PropertyStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPropertyStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PropertyStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PropertyStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPropertyStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PropertyStatus), nil
}

type PropertyType string

const (
	PropertyTypeHouse        PropertyType = "House"
	PropertyTypeApartment    PropertyType = "Apartment"
	PropertyTypeLand         PropertyType = "Land"
	PropertyTypeManufactured PropertyType = "Manufactured"
	PropertyTypeTownhome     PropertyType = "Townhome"
	PropertyTypeMultiFamily  PropertyType = "Multi-family"
	PropertyTypeCondo        PropertyType = "Condo"
	PropertyTypeCoOp         PropertyType = "Co-op"
	PropertyTypeLot          PropertyType = "Lot"
)

func (e *PropertyType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PropertyType(s)
	case string:
		*e = PropertyType(s)
	default:
		return fmt.Errorf("unsupported scan type for PropertyType: %T", src)
	}
	return nil
}

type NullPropertyType struct {
	PropertyType PropertyType `json:"property_type"`
	Valid        bool         `json:"valid"` // Valid is true if PropertyType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPropertyType) Scan(value interface{}) error {
	if value == nil {
		ns.PropertyType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PropertyType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPropertyType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PropertyType), nil
}

type ReviewType string

const (
	ReviewTypeProperty ReviewType = "Property"
	ReviewTypeHost     ReviewType = "Host"
	ReviewTypeGuest    ReviewType = "Guest"
)

func (e *ReviewType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ReviewType(s)
	case string:
		*e = ReviewType(s)
	default:
		return fmt.Errorf("unsupported scan type for ReviewType: %T", src)
	}
	return nil
}

type NullReviewType struct {
	ReviewType ReviewType `json:"review_type"`
	Valid      bool       `json:"valid"` // Valid is true if ReviewType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullReviewType) Scan(value interface{}) error {
	if value == nil {
		ns.ReviewType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ReviewType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullReviewType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ReviewType), nil
}

// Master list of all possible amenities, features, appliances, utilities, and parking options
type Amenity struct {
	ID uuid.UUID `json:"id"`
	// Name of the amenity
	Name string `json:"name"`
	// Detailed description of the amenity
	Description sql.NullString `json:"description"`
	// Icon reference for UI display
	Icon sql.NullString `json:"icon"`
	// Type of amenity (Feature, Amenity, Appliance, Utility, Parking)
	Category  AmenityCategory `json:"category"`
	CreatedAt sql.NullTime    `json:"created_at"`
	UpdatedAt sql.NullTime    `json:"updated_at"`
}

type Property struct {
	// Primary key
	ID uuid.UUID `json:"id"`
	// Property title
	Title string `json:"title"`
	// Detailed description
	Description sql.NullString `json:"description"`
	// Price of the property
	Price string `json:"price"`
	// Rent, Sale, Buy, Lease, Land, Mortgage, etc.
	Category PropertyCategory `json:"category"`
	// House, Apartment, Land, etc.
	Type PropertyType `json:"type"`
	// Address details
	Address string `json:"address"`
	// City
	City string `json:"city"`
	// State/Province
	State string `json:"state"`
	// Country
	Country string `json:"country"`
	// Zip code/Postal code
	ZipCode sql.NullString `json:"zip_code"`
	// Reference to the user (seller), external microservice
	OwnerID uuid.NullUUID `json:"owner_id"`
	// Available, Sold, Rented, etc.
	Status    PropertyStatus `json:"status"`
	CreatedAt sql.NullTime   `json:"created_at"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
}

// Links properties to their amenities with additional details
type PropertyAmenity struct {
	PropertyID uuid.UUID `json:"property_id"`
	AmenityID  uuid.UUID `json:"amenity_id"`
	// Indicates if property has this amenity (allows for explicitly noting absence)
	HasAmenity sql.NullBool `json:"has_amenity"`
	// Additional notes about this amenity for this property
	Notes sql.NullString `json:"notes"`
}

// Calendar availability for rental properties
type PropertyAvailability struct {
	ID          uuid.UUID    `json:"id"`
	PropertyID  uuid.UUID    `json:"property_id"`
	Date        time.Time    `json:"date"`
	IsAvailable sql.NullBool `json:"is_available"`
	// Special pricing for specific dates
	PriceOverride sql.NullString `json:"price_override"`
	// Minimum nights for bookings that include this date
	MinNights sql.NullInt32 `json:"min_nights"`
	// Maximum nights for bookings that include this date
	MaxNights sql.NullInt32 `json:"max_nights"`
	CreatedAt sql.NullTime  `json:"created_at"`
	UpdatedAt sql.NullTime  `json:"updated_at"`
}

// Detailed information about property features
type PropertyDetail struct {
	ID         uuid.UUID `json:"id"`
	PropertyID uuid.UUID `json:"property_id"`
	// Number of bedrooms
	Bedrooms sql.NullInt32 `json:"bedrooms"`
	// Number of bathrooms
	Bathrooms sql.NullInt32 `json:"bathrooms"`
	// Number of toilets
	Toilets sql.NullInt32 `json:"toilets"`
	// Total living area in square feet/meters
	SquareFootage sql.NullString `json:"square_footage"`
	// Size of the lot in square feet/meters
	LotSize sql.NullString `json:"lot_size"`
	// Year the property was built
	YearBuilt sql.NullInt32 `json:"year_built"`
	// Number of stories/floors
	Stories sql.NullInt32 `json:"stories"`
	// Number of garage spaces
	GarageCount      sql.NullInt32  `json:"garage_count"`
	HasBasement      sql.NullBool   `json:"has_basement"`
	HasAttic         sql.NullBool   `json:"has_attic"`
	HeatingSystem    sql.NullString `json:"heating_system"`
	CoolingSystem    sql.NullString `json:"cooling_system"`
	WaterSource      sql.NullString `json:"water_source"`
	SewerType        sql.NullString `json:"sewer_type"`
	RoofType         sql.NullString `json:"roof_type"`
	ExteriorMaterial sql.NullString `json:"exterior_material"`
	FoundationType   sql.NullString `json:"foundation_type"`
	PoolType         sql.NullString `json:"pool_type"`
	// Latitude & longitude (Optional)
	GeoLocation pqtype.NullRawMessage `json:"geo_location"`
	CreatedAt   sql.NullTime          `json:"created_at"`
	UpdatedAt   sql.NullTime          `json:"updated_at"`
}

// Property images with metadata
type PropertyImage struct {
	ID         uuid.UUID `json:"id"`
	PropertyID uuid.UUID `json:"property_id"`
	Url        string    `json:"url"`
	// Optional caption for the image
	Caption sql.NullString `json:"caption"`
	// Whether this is the main/featured image
	IsPrimary sql.NullBool `json:"is_primary"`
	// Order to display images in
	DisplayOrder sql.NullInt32 `json:"display_order"`
	// Type of room shown (e.g., Kitchen, Bathroom, Exterior)
	RoomType  sql.NullString `json:"room_type"`
	CreatedAt sql.NullTime   `json:"created_at"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
}

// Neighborhood information for properties
type PropertyNeighborhood struct {
	ID         uuid.UUID `json:"id"`
	PropertyID uuid.UUID `json:"property_id"`
	// School district name
	SchoolDistrict sql.NullString `json:"school_district"`
	// School district rating (1-10)
	SchoolRating sql.NullInt32 `json:"school_rating"`
	// Crime rate description
	CrimeRate sql.NullString `json:"crime_rate"`
	// Walkability score (0-100)
	WalkScore sql.NullInt32 `json:"walk_score"`
	// Public transit score (0-100)
	TransitScore sql.NullInt32 `json:"transit_score"`
	// Bikeability score (0-100)
	BikeScore sql.NullInt32 `json:"bike_score"`
	// JSON array of nearby points of interest
	NearbyLocations pqtype.NullRawMessage `json:"nearby_locations"`
	CreatedAt       sql.NullTime          `json:"created_at"`
	UpdatedAt       sql.NullTime          `json:"updated_at"`
}

// Tracks user views of properties
type PropertyView struct {
	// Primary key for the PropertyView table
	ID uuid.UUID `json:"id"`
	// Reference to the property viewed
	PropertyID uuid.UUID `json:"property_id"`
	// Reference to the user who viewed the property (from auth microservice)
	UserID uuid.UUID `json:"user_id"`
	// Timestamp of when the property was viewed
	ViewedAt sql.NullTime `json:"viewed_at"`
}

// Reviews for properties with detailed ratings
type Review struct {
	ID uuid.UUID `json:"id"`
	// External reference to booking from the booking microservice
	BookingID  uuid.NullUUID `json:"booking_id"`
	PropertyID uuid.UUID     `json:"property_id"`
	// User who wrote the review (from auth microservice)
	ReviewerID uuid.UUID `json:"reviewer_id"`
	// User being reviewed, if applicable (host/guest)
	ReviewedID uuid.NullUUID `json:"reviewed_id"`
	// Overall rating score
	OverallRating string `json:"overall_rating"`
	// Rating for location
	LocationRating sql.NullString `json:"location_rating"`
	// Rating for value
	ValueRating sql.NullString `json:"value_rating"`
	// Rating for listing accuracy
	AccuracyRating sql.NullString `json:"accuracy_rating"`
	// Rating for communication
	CommunicationRating sql.NullString `json:"communication_rating"`
	// Rating for cleanliness
	CleanlinessRating sql.NullString `json:"cleanliness_rating"`
	// Rating for check-in experience
	CheckInRating sql.NullString `json:"check_in_rating"`
	Comment       sql.NullString `json:"comment"`
	Type          ReviewType     `json:"type"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
}

// Properties saved/favorited by users
type SavedProperty struct {
	ID uuid.UUID `json:"id"`
	// Reference to the user (from auth microservice)
	UserID     uuid.UUID    `json:"user_id"`
	PropertyID uuid.UUID    `json:"property_id"`
	CreatedAt  sql.NullTime `json:"created_at"`
}

// User search history for properties
type SearchHistory struct {
	ID          uuid.UUID `json:"id"`
	UserID      uuid.UUID `json:"user_id"`
	SearchQuery string    `json:"search_query"`
	// Filters applied during search (location, price range, etc.)
	Filters   pqtype.NullRawMessage `json:"filters"`
	CreatedAt sql.NullTime          `json:"created_at"`
}
