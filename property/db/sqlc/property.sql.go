// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: property.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const countProperties = `-- name: CountProperties :one
SELECT COUNT(*) FROM "Property"
WHERE 
  ($1::property_category IS NULL OR category = $1) AND
  ($2::property_type IS NULL OR type = $2) AND
  ($3::property_status IS NULL OR status = $3) AND
  ($4::VARCHAR IS NULL OR city = $4) AND
  ($5::VARCHAR IS NULL OR state = $5) AND
  ($6::VARCHAR IS NULL OR country = $6) AND
  ($7::NUMERIC IS NULL OR price >= $7) AND
  ($8::NUMERIC IS NULL OR price <= $8)
`

type CountPropertiesParams struct {
	Column1 PropertyCategory `json:"column_1"`
	Column2 PropertyType     `json:"column_2"`
	Column3 PropertyStatus   `json:"column_3"`
	Column4 string           `json:"column_4"`
	Column5 string           `json:"column_5"`
	Column6 string           `json:"column_6"`
	Column7 decimal.Decimal  `json:"column_7"`
	Column8 decimal.Decimal  `json:"column_8"`
}

func (q *Queries) CountProperties(ctx context.Context, arg CountPropertiesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProperties,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProperty = `-- name: CreateProperty :one
INSERT INTO "Property" (
  id,
  title,
  description,
  price,
  category,
  type,
  address,
  city,
  state,
  country,
  zip_code,
  owner_id,
  status
) VALUES (
  gen_random_uuid(),
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, title, description, price, category, type, address, city, state, country, zip_code, owner_id, status, created_at, updated_at
`

type CreatePropertyParams struct {
	Title       string           `json:"title"`
	Description sql.NullString   `json:"description"`
	Price       decimal.Decimal  `json:"price"`
	Category    PropertyCategory `json:"category"`
	Type        PropertyType     `json:"type"`
	Address     string           `json:"address"`
	City        string           `json:"city"`
	State       string           `json:"state"`
	Country     string           `json:"country"`
	ZipCode     sql.NullString   `json:"zip_code"`
	OwnerID     uuid.NullUUID    `json:"owner_id"`
	Status      PropertyStatus   `json:"status"`
}

func (q *Queries) CreateProperty(ctx context.Context, arg CreatePropertyParams) (Property, error) {
	row := q.db.QueryRowContext(ctx, createProperty,
		arg.Title,
		arg.Description,
		arg.Price,
		arg.Category,
		arg.Type,
		arg.Address,
		arg.City,
		arg.State,
		arg.Country,
		arg.ZipCode,
		arg.OwnerID,
		arg.Status,
	)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Category,
		&i.Type,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.ZipCode,
		&i.OwnerID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProperty = `-- name: DeleteProperty :exec
DELETE FROM "Property"
WHERE id = $1
`

func (q *Queries) DeleteProperty(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteProperty, id)
	return err
}

const getPropertiesByOwner = `-- name: GetPropertiesByOwner :many
SELECT id, title, description, price, category, type, address, city, state, country, zip_code, owner_id, status, created_at, updated_at FROM "Property"
WHERE owner_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPropertiesByOwnerParams struct {
	OwnerID uuid.NullUUID `json:"owner_id"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
}

func (q *Queries) GetPropertiesByOwner(ctx context.Context, arg GetPropertiesByOwnerParams) ([]Property, error) {
	rows, err := q.db.QueryContext(ctx, getPropertiesByOwner, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Property{}
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Category,
			&i.Type,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.ZipCode,
			&i.OwnerID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyByID = `-- name: GetPropertyByID :one
SELECT id, title, description, price, category, type, address, city, state, country, zip_code, owner_id, status, created_at, updated_at FROM "Property"
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetPropertyByID(ctx context.Context, id uuid.UUID) (Property, error) {
	row := q.db.QueryRowContext(ctx, getPropertyByID, id)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Category,
		&i.Type,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.ZipCode,
		&i.OwnerID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listProperties = `-- name: ListProperties :many
SELECT 
  p.id, p.title, p.description, p.price, p.category, p.type, p.address, p.city, p.state, p.country, p.zip_code, p.owner_id, p.status, p.created_at, p.updated_at,
  pd.bedrooms,
  pd.bathrooms,
  pd.square_footage
FROM "Property" p
LEFT JOIN "PropertyDetail" pd ON p.id = pd.property_id
WHERE 
  ($1::property_category IS NULL OR p.category = $1) AND
  ($2::property_type IS NULL OR p.type = $2) AND
  ($3::property_status IS NULL OR p.status = $3) AND
  ($4::VARCHAR IS NULL OR p.city = $4) AND
  ($5::VARCHAR IS NULL OR p.state = $5) AND
  ($6::VARCHAR IS NULL OR p.country = $6) AND
  ($7::NUMERIC IS NULL OR p.price >= $7) AND
  ($8::NUMERIC IS NULL OR p.price <= $8) AND
  ($9::INT IS NULL OR pd.bedrooms >= $9) AND
  ($10::INT IS NULL OR pd.bathrooms >= $10)
ORDER BY p.created_at DESC
LIMIT $12
OFFSET $11
`

type ListPropertiesParams struct {
	Category     NullPropertyCategory `json:"category"`
	Type         NullPropertyType     `json:"type"`
	Status       NullPropertyStatus   `json:"status"`
	City         sql.NullString       `json:"city"`
	State        sql.NullString       `json:"state"`
	Country      sql.NullString       `json:"country"`
	MinPrice     sql.NullString       `json:"min_price"`
	MaxPrice     sql.NullString       `json:"max_price"`
	MinBedrooms  sql.NullInt32        `json:"min_bedrooms"`
	MinBathrooms sql.NullInt32        `json:"min_bathrooms"`
	Offset       int32                `json:"offset"`
	Limit        int32                `json:"limit"`
}

type ListPropertiesRow struct {
	ID            uuid.UUID        `json:"id"`
	Title         string           `json:"title"`
	Description   sql.NullString   `json:"description"`
	Price         decimal.Decimal  `json:"price"`
	Category      PropertyCategory `json:"category"`
	Type          PropertyType     `json:"type"`
	Address       string           `json:"address"`
	City          string           `json:"city"`
	State         string           `json:"state"`
	Country       string           `json:"country"`
	ZipCode       sql.NullString   `json:"zip_code"`
	OwnerID       uuid.NullUUID    `json:"owner_id"`
	Status        PropertyStatus   `json:"status"`
	CreatedAt     sql.NullTime     `json:"created_at"`
	UpdatedAt     sql.NullTime     `json:"updated_at"`
	Bedrooms      sql.NullInt32    `json:"bedrooms"`
	Bathrooms     sql.NullInt32    `json:"bathrooms"`
	SquareFootage sql.NullString   `json:"square_footage"`
}

func (q *Queries) ListProperties(ctx context.Context, arg ListPropertiesParams) ([]ListPropertiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listProperties,
		arg.Category,
		arg.Type,
		arg.Status,
		arg.City,
		arg.State,
		arg.Country,
		arg.MinPrice,
		arg.MaxPrice,
		arg.MinBedrooms,
		arg.MinBathrooms,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPropertiesRow{}
	for rows.Next() {
		var i ListPropertiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Category,
			&i.Type,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.ZipCode,
			&i.OwnerID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Bedrooms,
			&i.Bathrooms,
			&i.SquareFootage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProperty = `-- name: UpdateProperty :one
UPDATE "Property"
SET
  title = COALESCE($2, title),
  description = COALESCE($3, description),
  price = COALESCE($4, price),
  category = COALESCE($5, category),
  type = COALESCE($6, type),
  address = COALESCE($7, address),
  city = COALESCE($8, city),
  state = COALESCE($9, state),
  country = COALESCE($10, country),
  zip_code = COALESCE($11, zip_code),
  status = COALESCE($12, status),
  updated_at = now()
WHERE id = $1
RETURNING id, title, description, price, category, type, address, city, state, country, zip_code, owner_id, status, created_at, updated_at
`

type UpdatePropertyParams struct {
	ID          uuid.UUID        `json:"id"`
	Title       string           `json:"title"`
	Description sql.NullString   `json:"description"`
	Price       decimal.Decimal  `json:"price"`
	Category    PropertyCategory `json:"category"`
	Type        PropertyType     `json:"type"`
	Address     string           `json:"address"`
	City        string           `json:"city"`
	State       string           `json:"state"`
	Country     string           `json:"country"`
	ZipCode     sql.NullString   `json:"zip_code"`
	Status      PropertyStatus   `json:"status"`
}

func (q *Queries) UpdateProperty(ctx context.Context, arg UpdatePropertyParams) (Property, error) {
	row := q.db.QueryRowContext(ctx, updateProperty,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Price,
		arg.Category,
		arg.Type,
		arg.Address,
		arg.City,
		arg.State,
		arg.Country,
		arg.ZipCode,
		arg.Status,
	)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Category,
		&i.Type,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.ZipCode,
		&i.OwnerID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePropertyStatus = `-- name: UpdatePropertyStatus :one
UPDATE "Property"
SET
  status = $2,
  updated_at = now()
WHERE id = $1
RETURNING id, title, description, price, category, type, address, city, state, country, zip_code, owner_id, status, created_at, updated_at
`

type UpdatePropertyStatusParams struct {
	ID     uuid.UUID      `json:"id"`
	Status PropertyStatus `json:"status"`
}

func (q *Queries) UpdatePropertyStatus(ctx context.Context, arg UpdatePropertyStatusParams) (Property, error) {
	row := q.db.QueryRowContext(ctx, updatePropertyStatus, arg.ID, arg.Status)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Category,
		&i.Type,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.ZipCode,
		&i.OwnerID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
