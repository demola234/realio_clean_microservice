// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: property_amenity.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const addPropertyAmenity = `-- name: AddPropertyAmenity :exec
INSERT INTO "PropertyAmenity" (
  property_id,
  amenity_id,
  has_amenity,
  notes
) VALUES (
  $1, $2, $3, $4
)
ON CONFLICT (property_id, amenity_id)
DO UPDATE
SET
  has_amenity = $3,
  notes = $4
`

type AddPropertyAmenityParams struct {
	PropertyID uuid.UUID      `json:"property_id"`
	AmenityID  uuid.UUID      `json:"amenity_id"`
	HasAmenity sql.NullBool   `json:"has_amenity"`
	Notes      sql.NullString `json:"notes"`
}

func (q *Queries) AddPropertyAmenity(ctx context.Context, arg AddPropertyAmenityParams) error {
	_, err := q.db.ExecContext(ctx, addPropertyAmenity,
		arg.PropertyID,
		arg.AmenityID,
		arg.HasAmenity,
		arg.Notes,
	)
	return err
}

const getPropertyAmenities = `-- name: GetPropertyAmenities :many
SELECT
  a.id, a.name, a.description, a.icon, a.category, a.created_at, a.updated_at,
  pa.has_amenity,
  pa.notes
FROM "PropertyAmenity" pa
JOIN "Amenity" a ON pa.amenity_id = a.id
WHERE pa.property_id = $1
ORDER BY a.category, a.name
`

type GetPropertyAmenitiesRow struct {
	ID          uuid.UUID       `json:"id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Icon        sql.NullString  `json:"icon"`
	Category    AmenityCategory `json:"category"`
	CreatedAt   sql.NullTime    `json:"created_at"`
	UpdatedAt   sql.NullTime    `json:"updated_at"`
	HasAmenity  sql.NullBool    `json:"has_amenity"`
	Notes       sql.NullString  `json:"notes"`
}

func (q *Queries) GetPropertyAmenities(ctx context.Context, propertyID uuid.UUID) ([]GetPropertyAmenitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPropertyAmenities, propertyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPropertyAmenitiesRow{}
	for rows.Next() {
		var i GetPropertyAmenitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Category,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HasAmenity,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllPropertyAmenities = `-- name: RemoveAllPropertyAmenities :exec
DELETE FROM "PropertyAmenity"
WHERE property_id = $1
`

func (q *Queries) RemoveAllPropertyAmenities(ctx context.Context, propertyID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removeAllPropertyAmenities, propertyID)
	return err
}

const removePropertyAmenity = `-- name: RemovePropertyAmenity :exec
DELETE FROM "PropertyAmenity"
WHERE property_id = $1 AND amenity_id = $2
`

type RemovePropertyAmenityParams struct {
	PropertyID uuid.UUID `json:"property_id"`
	AmenityID  uuid.UUID `json:"amenity_id"`
}

func (q *Queries) RemovePropertyAmenity(ctx context.Context, arg RemovePropertyAmenityParams) error {
	_, err := q.db.ExecContext(ctx, removePropertyAmenity, arg.PropertyID, arg.AmenityID)
	return err
}
