// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: complex.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const getPropertiesByAmenity = `-- name: GetPropertiesByAmenity :many
SELECT 
  p.id, p.title, p.description, p.price, p.category, p.type, p.address, p.city, p.state, p.country, p.zip_code, p.owner_id, p.status, p.created_at, p.updated_at
FROM "Property" p
JOIN "PropertyAmenity" pa ON p.id = pa.property_id
JOIN "Amenity" a ON pa.amenity_id = a.id
WHERE 
  pa.has_amenity = true AND
  a.id = $1 AND
  ($2::property_status IS NULL OR p.status = $2)
ORDER BY p.created_at DESC
LIMIT $3
OFFSET $4
`

type GetPropertiesByAmenityParams struct {
	ID      uuid.UUID      `json:"id"`
	Column2 PropertyStatus `json:"column_2"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) GetPropertiesByAmenity(ctx context.Context, arg GetPropertiesByAmenityParams) ([]Property, error) {
	rows, err := q.db.QueryContext(ctx, getPropertiesByAmenity,
		arg.ID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Property{}
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Category,
			&i.Type,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.ZipCode,
			&i.OwnerID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertiesByMultipleAmenities = `-- name: GetPropertiesByMultipleAmenities :many
SELECT 
  p.id, p.title, p.description, p.price, p.category, p.type, p.address, p.city, p.state, p.country, p.zip_code, p.owner_id, p.status, p.created_at, p.updated_at,
  COUNT(pa.amenity_id) as matched_amenities
FROM "Property" p
JOIN "PropertyAmenity" pa ON p.id = pa.property_id
WHERE 
  pa.has_amenity = true AND
  pa.amenity_id = ANY($1::UUID[]) AND
  ($2::property_status IS NULL OR p.status = $2)
GROUP BY p.id
ORDER BY matched_amenities DESC, p.created_at DESC
LIMIT $3
OFFSET $4
`

type GetPropertiesByMultipleAmenitiesParams struct {
	Column1 []uuid.UUID    `json:"column_1"`
	Column2 PropertyStatus `json:"column_2"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

type GetPropertiesByMultipleAmenitiesRow struct {
	ID               uuid.UUID        `json:"id"`
	Title            string           `json:"title"`
	Description      sql.NullString   `json:"description"`
	Price            string           `json:"price"`
	Category         PropertyCategory `json:"category"`
	Type             PropertyType     `json:"type"`
	Address          string           `json:"address"`
	City             string           `json:"city"`
	State            string           `json:"state"`
	Country          string           `json:"country"`
	ZipCode          sql.NullString   `json:"zip_code"`
	OwnerID          uuid.NullUUID    `json:"owner_id"`
	Status           PropertyStatus   `json:"status"`
	CreatedAt        sql.NullTime     `json:"created_at"`
	UpdatedAt        sql.NullTime     `json:"updated_at"`
	MatchedAmenities int64            `json:"matched_amenities"`
}

func (q *Queries) GetPropertiesByMultipleAmenities(ctx context.Context, arg GetPropertiesByMultipleAmenitiesParams) ([]GetPropertiesByMultipleAmenitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPropertiesByMultipleAmenities,
		pq.Array(arg.Column1),
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPropertiesByMultipleAmenitiesRow{}
	for rows.Next() {
		var i GetPropertiesByMultipleAmenitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Category,
			&i.Type,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.ZipCode,
			&i.OwnerID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MatchedAmenities,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyWithAllDetails = `-- name: GetPropertyWithAllDetails :one
SELECT 
  p.id, p.title, p.description, p.price, p.category, p.type, p.address, p.city, p.state, p.country, p.zip_code, p.owner_id, p.status, p.created_at, p.updated_at,
  pd.id, pd.property_id, pd.bedrooms, pd.bathrooms, pd.toilets, pd.square_footage, pd.lot_size, pd.year_built, pd.stories, pd.garage_count, pd.has_basement, pd.has_attic, pd.heating_system, pd.cooling_system, pd.water_source, pd.sewer_type, pd.roof_type, pd.exterior_material, pd.foundation_type, pd.pool_type, pd.geo_location, pd.created_at, pd.updated_at,
  pn.id, pn.property_id, pn.school_district, pn.school_rating, pn.crime_rate, pn.walk_score, pn.transit_score, pn.bike_score, pn.nearby_locations, pn.created_at, pn.updated_at,
  COALESCE(rev_stats.avg_rating, 0) as avg_rating,
  COALESCE(rev_stats.review_count, 0) as review_count
FROM "Property" p
LEFT JOIN "PropertyDetail" pd ON p.id = pd.property_id
LEFT JOIN "PropertyNeighborhood" pn ON p.id = pn.property_id
LEFT JOIN (
  SELECT 
    property_id, 
    AVG(overall_rating) as avg_rating,
    COUNT(*) as review_count
  FROM "Review"
  GROUP BY property_id
) rev_stats ON p.id = rev_stats.property_id
WHERE p.id = $1
LIMIT 1
`

type GetPropertyWithAllDetailsRow struct {
	ID               uuid.UUID             `json:"id"`
	Title            string                `json:"title"`
	Description      sql.NullString        `json:"description"`
	Price            string                `json:"price"`
	Category         PropertyCategory      `json:"category"`
	Type             PropertyType          `json:"type"`
	Address          string                `json:"address"`
	City             string                `json:"city"`
	State            string                `json:"state"`
	Country          string                `json:"country"`
	ZipCode          sql.NullString        `json:"zip_code"`
	OwnerID          uuid.NullUUID         `json:"owner_id"`
	Status           PropertyStatus        `json:"status"`
	CreatedAt        sql.NullTime          `json:"created_at"`
	UpdatedAt        sql.NullTime          `json:"updated_at"`
	ID_2             uuid.NullUUID         `json:"id_2"`
	PropertyID       uuid.NullUUID         `json:"property_id"`
	Bedrooms         sql.NullInt32         `json:"bedrooms"`
	Bathrooms        sql.NullInt32         `json:"bathrooms"`
	Toilets          sql.NullInt32         `json:"toilets"`
	SquareFootage    sql.NullString        `json:"square_footage"`
	LotSize          sql.NullString        `json:"lot_size"`
	YearBuilt        sql.NullInt32         `json:"year_built"`
	Stories          sql.NullInt32         `json:"stories"`
	GarageCount      sql.NullInt32         `json:"garage_count"`
	HasBasement      sql.NullBool          `json:"has_basement"`
	HasAttic         sql.NullBool          `json:"has_attic"`
	HeatingSystem    sql.NullString        `json:"heating_system"`
	CoolingSystem    sql.NullString        `json:"cooling_system"`
	WaterSource      sql.NullString        `json:"water_source"`
	SewerType        sql.NullString        `json:"sewer_type"`
	RoofType         sql.NullString        `json:"roof_type"`
	ExteriorMaterial sql.NullString        `json:"exterior_material"`
	FoundationType   sql.NullString        `json:"foundation_type"`
	PoolType         sql.NullString        `json:"pool_type"`
	GeoLocation      pqtype.NullRawMessage `json:"geo_location"`
	CreatedAt_2      sql.NullTime          `json:"created_at_2"`
	UpdatedAt_2      sql.NullTime          `json:"updated_at_2"`
	ID_3             uuid.NullUUID         `json:"id_3"`
	PropertyID_2     uuid.NullUUID         `json:"property_id_2"`
	SchoolDistrict   sql.NullString        `json:"school_district"`
	SchoolRating     sql.NullInt32         `json:"school_rating"`
	CrimeRate        sql.NullString        `json:"crime_rate"`
	WalkScore        sql.NullInt32         `json:"walk_score"`
	TransitScore     sql.NullInt32         `json:"transit_score"`
	BikeScore        sql.NullInt32         `json:"bike_score"`
	NearbyLocations  pqtype.NullRawMessage `json:"nearby_locations"`
	CreatedAt_3      sql.NullTime          `json:"created_at_3"`
	UpdatedAt_3      sql.NullTime          `json:"updated_at_3"`
	AvgRating        float64               `json:"avg_rating"`
	ReviewCount      int64                 `json:"review_count"`
}

func (q *Queries) GetPropertyWithAllDetails(ctx context.Context, id uuid.UUID) (GetPropertyWithAllDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getPropertyWithAllDetails, id)
	var i GetPropertyWithAllDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Category,
		&i.Type,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.ZipCode,
		&i.OwnerID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.PropertyID,
		&i.Bedrooms,
		&i.Bathrooms,
		&i.Toilets,
		&i.SquareFootage,
		&i.LotSize,
		&i.YearBuilt,
		&i.Stories,
		&i.GarageCount,
		&i.HasBasement,
		&i.HasAttic,
		&i.HeatingSystem,
		&i.CoolingSystem,
		&i.WaterSource,
		&i.SewerType,
		&i.RoofType,
		&i.ExteriorMaterial,
		&i.FoundationType,
		&i.PoolType,
		&i.GeoLocation,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.ID_3,
		&i.PropertyID_2,
		&i.SchoolDistrict,
		&i.SchoolRating,
		&i.CrimeRate,
		&i.WalkScore,
		&i.TransitScore,
		&i.BikeScore,
		&i.NearbyLocations,
		&i.CreatedAt_3,
		&i.UpdatedAt_3,
		&i.AvgRating,
		&i.ReviewCount,
	)
	return i, err
}

const searchPropertiesWithDetails = `-- name: SearchPropertiesWithDetails :many
SELECT 
  p.id, p.title, p.description, p.price, p.category, p.type, p.address, p.city, p.state, p.country, p.zip_code, p.owner_id, p.status, p.created_at, p.updated_at,
  pd.bedrooms,
  pd.bathrooms,
  pd.square_footage,
  pd.lot_size,
  pd.year_built,
  pd.stories,
  pd.garage_count,
  pd.has_basement,
  pd.has_attic,
  pn.walk_score,
  pn.transit_score,
  pn.school_rating,
  COALESCE(rev_stats.avg_rating, 0) as avg_rating,
  COALESCE(rev_stats.review_count, 0) as review_count
FROM "Property" p
LEFT JOIN "PropertyDetail" pd ON p.id = pd.property_id
LEFT JOIN "PropertyNeighborhood" pn ON p.id = pn.property_id
LEFT JOIN (
  SELECT 
    property_id, 
    AVG(overall_rating) as avg_rating,
    COUNT(*) as review_count
  FROM "Review"
  GROUP BY property_id
) rev_stats ON p.id = rev_stats.property_id
WHERE 
  ($1::property_category IS NULL OR p.category = $1) AND
  ($2::property_type IS NULL OR p.type = $2) AND
  ($3::property_status IS NULL OR p.status = $3) AND
  ($4::VARCHAR IS NULL OR p.city ILIKE '%' || $4 || '%') AND
  ($5::VARCHAR IS NULL OR p.state ILIKE '%' || $5 || '%') AND
  ($6::VARCHAR IS NULL OR p.country ILIKE '%' || $6 || '%') AND
  ($7::NUMERIC IS NULL OR p.price >= $7) AND
  ($8::NUMERIC IS NULL OR p.price <= $8) AND
  ($9::INT IS NULL OR pd.bedrooms >= $9) AND
  ($10::INT IS NULL OR pd.bathrooms >= $10) AND
  ($11::INT IS NULL OR pd.square_footage >= $11) AND
  ($12::INT IS NULL OR pd.year_built >= $12) AND
  ($13::INT IS NULL OR pd.garage_count >= $13) AND
  ($14::BOOLEAN IS NULL OR pd.has_basement = $14) AND
  ($15::BOOLEAN IS NULL OR pd.has_attic = $15) AND
  ($16::INT IS NULL OR pn.walk_score >= $16) AND
  ($17::INT IS NULL OR pn.school_rating >= $17)
ORDER BY 
  CASE WHEN $18 = 'price_asc' THEN p.price END ASC,
  CASE WHEN $18 = 'price_desc' THEN p.price END DESC,
  CASE WHEN $18 = 'newest' THEN p.created_at END DESC,
  CASE WHEN $18 = 'oldest' THEN p.created_at END ASC,
  CASE WHEN $18 = 'rating' THEN rev_stats.avg_rating END DESC,
  CASE WHEN $18 = 'most_reviewed' THEN rev_stats.review_count END DESC,
  p.created_at DESC
LIMIT $19
OFFSET $20
`

type SearchPropertiesWithDetailsParams struct {
	Column1  PropertyCategory `json:"column_1"`
	Column2  PropertyType     `json:"column_2"`
	Column3  PropertyStatus   `json:"column_3"`
	Column4  string           `json:"column_4"`
	Column5  string           `json:"column_5"`
	Column6  string           `json:"column_6"`
	Column7  string           `json:"column_7"`
	Column8  string           `json:"column_8"`
	Column9  int32            `json:"column_9"`
	Column10 int32            `json:"column_10"`
	Column11 int32            `json:"column_11"`
	Column12 int32            `json:"column_12"`
	Column13 int32            `json:"column_13"`
	Column14 bool             `json:"column_14"`
	Column15 bool             `json:"column_15"`
	Column16 int32            `json:"column_16"`
	Column17 int32            `json:"column_17"`
	Column18 interface{}      `json:"column_18"`
	Limit    int32            `json:"limit"`
	Offset   int32            `json:"offset"`
}

type SearchPropertiesWithDetailsRow struct {
	ID            uuid.UUID        `json:"id"`
	Title         string           `json:"title"`
	Description   sql.NullString   `json:"description"`
	Price         string           `json:"price"`
	Category      PropertyCategory `json:"category"`
	Type          PropertyType     `json:"type"`
	Address       string           `json:"address"`
	City          string           `json:"city"`
	State         string           `json:"state"`
	Country       string           `json:"country"`
	ZipCode       sql.NullString   `json:"zip_code"`
	OwnerID       uuid.NullUUID    `json:"owner_id"`
	Status        PropertyStatus   `json:"status"`
	CreatedAt     sql.NullTime     `json:"created_at"`
	UpdatedAt     sql.NullTime     `json:"updated_at"`
	Bedrooms      sql.NullInt32    `json:"bedrooms"`
	Bathrooms     sql.NullInt32    `json:"bathrooms"`
	SquareFootage sql.NullString   `json:"square_footage"`
	LotSize       sql.NullString   `json:"lot_size"`
	YearBuilt     sql.NullInt32    `json:"year_built"`
	Stories       sql.NullInt32    `json:"stories"`
	GarageCount   sql.NullInt32    `json:"garage_count"`
	HasBasement   sql.NullBool     `json:"has_basement"`
	HasAttic      sql.NullBool     `json:"has_attic"`
	WalkScore     sql.NullInt32    `json:"walk_score"`
	TransitScore  sql.NullInt32    `json:"transit_score"`
	SchoolRating  sql.NullInt32    `json:"school_rating"`
	AvgRating     float64          `json:"avg_rating"`
	ReviewCount   int64            `json:"review_count"`
}

func (q *Queries) SearchPropertiesWithDetails(ctx context.Context, arg SearchPropertiesWithDetailsParams) ([]SearchPropertiesWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchPropertiesWithDetails,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
		arg.Column11,
		arg.Column12,
		arg.Column13,
		arg.Column14,
		arg.Column15,
		arg.Column16,
		arg.Column17,
		arg.Column18,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchPropertiesWithDetailsRow{}
	for rows.Next() {
		var i SearchPropertiesWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Category,
			&i.Type,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.ZipCode,
			&i.OwnerID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Bedrooms,
			&i.Bathrooms,
			&i.SquareFootage,
			&i.LotSize,
			&i.YearBuilt,
			&i.Stories,
			&i.GarageCount,
			&i.HasBasement,
			&i.HasAttic,
			&i.WalkScore,
			&i.TransitScore,
			&i.SchoolRating,
			&i.AvgRating,
			&i.ReviewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
